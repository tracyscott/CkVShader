/*{
	"DESCRIPTION": "Pulsing center orb that explodes into an outward-moving ring; loops when ring exits",
	"CREDIT": "by tracyscott + Roo",
	"ISFVSN": "2.0",
	"CATEGORIES": [
		"VERTEX SDF",
		"GEOMETRIC",
		"PARTICLES"
	],
	"INPUTS": [
		{
			"NAME": "scale",
			"TYPE": "float",
			"DEFAULT": 0.35,
			"MIN": 0.05,
			"MAX": 0.8
		},
		{
			"NAME": "spd",
			"TYPE": "float",
			"DEFAULT": 0.6,
			"MIN": 0.0,
			"MAX": 3.0
		},
		{
			"NAME": "cycleTime",
			"TYPE": "float",
			"DEFAULT": 4.0,
			"MIN": 0.5,
			"MAX": 12.0
		},
		{
			"NAME": "ringWidth",
			"TYPE": "float",
			"DEFAULT": 0.02,
			"MIN": 0.002,
			"MAX": 0.12
		},
		{
			"NAME": "thickness",
			"TYPE": "float",
			"DEFAULT": 0.02,
			"MIN": 0.0003,
			"MAX": 0.08
		},
		{
			"NAME": "paletteIdx",
			"TYPE": "float",
			"DEFAULT": 2.0,
			"MIN": 1.0,
			"MAX": 5.0
		},
		{
			"NAME": "pw",
			"TYPE": "float",
			"DEFAULT": 1.0,
			"MIN": 0.2,
			"MAX": 8.0
		}
	]
}*/

#version 330

uniform float fTime;
uniform float scale;      // unused for this effect (kept for compatibility)
uniform float spd;        // global speed multiplier
uniform float thickness;  // core glow thickness (center orb tightness)
uniform float paletteIdx; // palette selector for paletteN
uniform float pw;         // falloff exponent for pow()
uniform float cycleTime;  // seconds per center->ring loop
uniform float ringWidth;  // thickness of the ring

// Additional controls for explosion timing/shape
const float uExplode = 0.45; // portion (0..1) of cycle spent on center orb buildup

layout(location = 0) in vec3 position;
out vec3 outColor;

#include <palettes.vti>
#include <sdf2d.vti>
#include <consts.vti>

// 2D rotation
vec2 rot2(vec2 p, float a){
	float c = cos(a), s = sin(a);
	return mat2(c, -s, s, c) * p;
}

// Smooth inverse falloff 1/d with softening to avoid singularities
float invFalloff(float d, float k){
	// k ~ core size; add epsilon for safety
	return 1.0 / max(d + k, 1e-4);
}

// Sharper core profile for tight balls: 1 / (d + k)^p, remapped to 0..1 with a hard clamp
float sharpCore(float d, float k, float p){
	float denom = max(d + k, 1e-4);
	float v = 1.0 / pow(denom, p);
	// normalize relative to value at d=0 so core is ~1 before clamp
	float v0 = 1.0 / pow(k + 1e-4, p);
	float n = v / v0;
	// hard clip to keep peaks tight and prevent bloom
	return clamp(n, 0.0, 1.0);
}

// Gaussian ring profile centered at radius r0 with width w (sigma)
float ringProfile(float r, float r0, float w){
	float s = max(w, 1e-4);
	float x = (r - r0) / s;
	return exp(-0.5 * x * x);
}

// Figure-eight helpers no longer used in this effect (kept for reference)
vec2 fig8(float t, float sc, float phase, float angle){
	float w = t;
	vec2 p = vec2(cos(w + phase), 0.5 * sin(2.0 * (w + phase)));
	p *= sc;
	return rot2(p, angle);
}

// Mid-edge positions kept for compatibility (unused)
vec2 edgePos(int i){
	if (i == 0) return vec2(0.0,  0.5);
	if (i == 1) return vec2(0.5,  0.0);
	if (i == 2) return vec2(0.0, -0.5);
	return vec2(-0.5, 0.0);
}

void main(){
	// Centered coordinates
	vec2 uv = position.xy - 0.5;
	float r = length(uv);

	// Disk mask so we only render inside the circular LED disk
	float diskMask = 1.0 - smoothstep(0.49, 0.50, r);

	// Time normalized over cycle, affected by spd
	float T = max(0.1, cycleTime) / max(0.1, spd + 0.0001);
	float tCycle = mod(fTime, T);
	float u = tCycle / T; // 0..1

	// Base palette color
	vec3 baseCol = paletteN(fTime * 0.15, clamp(paletteIdx, 1.0, 5.0));

	vec3 col = vec3(0.0);

	if (u < uExplode){
		// Center orb phase: small, vibrating, increasing intensity
		float k = clamp(thickness, 0.0003, 0.06);
		float pExp = clamp(pw * 2.4, 2.6, 7.0);

		// Subtle vibration
		float vibAmp = 0.02;
		vec2 jitter = vec2(
			sin(13.0 * fTime) + 0.5 * sin(7.0 * fTime + 1.7),
			cos(11.0 * fTime) + 0.5 * sin(9.0 * fTime + 0.9)
		) * vibAmp * smoothstep(0.0, uExplode, u);

		float d = length(uv - jitter);
		float core = sharpCore(d, k, pExp);

		float grow = pow(smoothstep(0.0, 1.0, u / uExplode), 1.2);
		float halo = 0.05 * exp(- (d * d) / max((k * 0.25)*(k * 0.25), 1e-6));
		float orb = clamp(core + halo, 0.0, 1.4) * grow;
		col += baseCol * orb;
	}else{
		// Explosion ring phase
		float kRing = max(ringWidth, 0.002);
		float v = (u - uExplode) / (1.0 - uExplode); // 0..1

		float rMax = 0.52; // extend beyond disk
		float r0 = rMax * v;

		float ring = ringProfile(r, r0, kRing);
		float shell = ringProfile(r, r0, kRing * 0.5) * 0.7;

		// Energy envelope: pop early then taper
		float burst = exp(-4.0 * (v - 0.15) * (v - 0.15));

		vec3 ringCol = paletteN(fTime * 0.25 + 1.3, clamp(paletteIdx, 1.0, 5.0));
		float ringEnergy = clamp(ring * 0.9 + shell, 0.0, 1.4) * burst;
		col += ringCol * ringEnergy;
	}

	col *= diskMask;

	// Tone scaling for visibility while keeping edges tight
	col *= 0.85;

	outColor = clamp(col, 0.0, 1.0);
}